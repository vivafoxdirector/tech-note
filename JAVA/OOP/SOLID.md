# 객체 지향의 디자인의 5원칙 (SOLID 원칙)
객체 지향의 4대 특성인 캡슐화, 상속, 추상화, 다형성을 이용하여 객체 지향을 올바르게 설계할 수 있도록 도와주는 원칙들을 알아 본다.

아무리 객체 지향 4대 특성인 캡슐화, 상속, 추상화, 다형성을 잘 한다고 해서 설계를 잘하는 것은 아니다. 물론 4대 특성의 묘미를 잘 살릴 수록 설계가 좋다. 하지만 설계 원칙이라는 게 엄연히 존재하고, 또 나름 중요하기 때문에 각 원칙의 맨 앞 알파벳만 따서 "SOLID"라고 까지 했을까?

SOLID원칙들은 결국 자기 자신 클래스 안에 응집도는 내부적으로 높이고, 타 클래스들 간 결합도는 낮추는 High Cohesion - Loose Coupling원칙을 객체 지향의 관점에서 도입한 것이다. 왜 그랬을까? 간단하다. 좋은 소프트웨어는 응집도가 높고 결합도가 낮기 때문이다. 결국 모듈 또는 클래스 당 하나의 책임을 주어 더욱더 독립된 모듈(클래스)을 만들기 위함이다. 이렇게 설계된 소프트웨어는 재 사용이 많아지고, 수정이 최소화 되기 때문에 결국 유지 보수가 용이해진다.

그럼 객체 지향 설계 5대 원칙이 각각 무엇인지 알아본다.

1. SRP (Single Responsibility Principle)단일 책임 원칙
2. OCP (Open Closed Principle) 개발 폐쇄 원칙
3. LSP (Liskov Substitution Principle) 리스코프 치환 원칙
4. ISP (Interface Segregation Principle) 인터페이스 분리 원칙
5. DIP (Dependency Inversion Principle) 의존 역전 원칙

# SRP (Single responsibility Principle) 단일 책임 원칙
"어떤 클래스를 변경해야 하는 이유는 오직 하나 뿐이어야 한다." - 로버트 C.마틴
즉, 클래스의 역할과 책임을 너무 많이 주지 마라.
* 모든 클래스는 단 하나의 책임을 가진다. 다시 말하면 클래스를 수정할 이유가 오직 하나여야 한다는 뜻
* 예를 들어, 계산기 클래스가 있을때, 계산을 하는 책임과 GUI를 나타낸다는 책임은 서로 분리되어야 한다. 계산기 클래스에 GUI를 나타내는 부분까지 있을 경우, 이는 SRP를 위반한다.

# OCP (Open Closed Principle) 개방 폐쇄 원칙
"소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다" - 로버트 C.마틴
즉, 자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다.
* 확장에 대해서는 개방 되어야 하지만, 수정에 대해서는 폐쇄 되어야 한다.
* 예를 들어, 캐릭터를 하나 생성한다고 할 때, 각각의 캐릭터가 움직임이 다를 경우 움직임의 패턴 구현을 하위 클래스에 맡긴다면 캐릭터 클래스의 수정은 필요가 없고(수정에 대해 폐쇄)움직임의 패턴만 재정의 하면 된다.(확장에 대한 개방)

# LSP (Liskov Substitution Principle) 리스코프 치환 원칙
"서브 타입은 언제나 자신의 기반 타입(base type)으로 교체할 수 있어야 한다." - 로버트 C. 마틴
1. 하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 이느턴스 역할을 하는데 문제가 없어야 한다.
2. Upcating 된 객체 참조 변수가 논리적으로 그 역할이 문제가 없어야 한다.

LSP(리스코프 치환 원칙)은 인터페이스와 클래스 관계, 상위 클래스와 하위 클래스 관계를 얼마나 잘 논리적으로 설계 했느냐가 관건이다.

상위 클래스와 하위 클래스는 무슨 관계인가?? 말 그대로 상위, 하위라고 불릴 수 있는 것은 상속관계가 성립된다는 뜻이며, 또 하위 클래스는 is a kind of 상위 클래스이다. 즉 우리가 상속에 대해 오해하고 있는 아버지와 아들 이런 계층적인 구조가 아니란 말이다. 상위, 하위 클래스를 설계하는 것은 계층이 아니라 분류이다. 또한 상속 = 확장이라고 생각 해야 한다.

잘못된 상속 관계 : 아버지와 아들 // 아들은 아버지의 한 종류이다??

올바른 상속 관계 : 포유류와 고래 // 고래는 포유류의 한 종류이다.

또한 클래스와 인터페이스 관계를 설명하면, 구현 클래스는 인터페이스로 인해 인터페이스 할 수 있음을 뜻한다. 인터페이스 이름을 잘 보면 통상적으로 ~able을 붙인다는 것을 알 수 있다. 이 말은 ~할 수 있는 이라는 뜻이다. 예를 들어
Runnable: ~실행 할 수 있는
Closeable: ~닫을 수 있는
Openable: ~열 수 있는
Swimable: ~수영 할 수 있는
~able을 붙여서 문법적으로 안 맞는 것은 일단 신경쓰지 말고, 인터페이스는 위와 같이 ~able을 붙여서 네이밍하고 인터페이스를 implements한 구현 클래스는 인터페이스가 가지고 있는 기능을 할 수 있다고 생각하면 된다.

LSP(리스코프 치환 원칙)에 대해서 알아 보았다. 처음 LSP(리스코프 치환 원칙)에 대해서 의역한 말을 생각해보자.

"하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는데 문제가 없어야 한다."

자 LSP(리스코프 치환 원칙)맞게 대입해보자. 자 다시 한번 LSP(리스코프 치환 원칙)은 하위클래스가 상위 클래스 역할을 대신할 때 논리적으로 맞아 떨어져야 한다.

아버지클래스 홍길동 = new 아들(); // LSP위배
포유류클래스 도커 = new 고래(); // 이 과정은 자바는 자동 타입 변환해 준다

아들이 태어나 홍길동이라는 이름을 짓고 아버지의 행위를 한다??? 어색함.
고래 한마리가 태어나 도커라는 이름을 짓고 포유류의 행위를 한다. 깔끔하다

객체 지향은 인간이 실셰계를 보면서 느끼고 논리적으로 이해한 것과 똑같이 프로그래밍하는 게 목적이기 때문에 논리적으로 맞아 떨어져야 한다.

# ISP (Interface Segregation Principle) 인터페이스 분리 원칙
"클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다." - 로버트 C.마틴
즉, 상황과 관련 있는 메서드만 제공하라.

ISP(인터페이스 분리 원칙)은 SRP(단일 책임 원칙)과 같은 원인에 대한 다른 해결책을 제시하는 거이다. 너무 많은 책임을 주어 상황에 관련 되지 않은 메서드까지 구현했다면, SRP(단일 책임 원칙)은 그 클래스를 여러개의 클래스로 쪼개버린다. 하지만 ISP(인터페이스 분리 원칙)은 해당 클래스를 그냥 냅 두는 상태에서 인터페이스 최소주의 원칙에 따라 각 상황에 맞는 기능만 제공하도록 필터링 한다고 생각하면 쉽다. 

## DIP (Dependency Inersion Principle) 의존 역전 원칙
의존성은 구체화가 아닌 추상화가 아니면 안된다.
"고차원 모듈은 저차원 모듈에 의존하면 안된다. 이 두 모듈 모두 다른 추상화 된 것에 의존해야 한다."
"추상화 된 것은 구체적인 것에 의존하면 안된다. 구체적인 것이 추상화 된 것에 의존해야 한다."
"주주 변경되는 구체(Concrete)클래스에 의존하지 마라" - 로버트 C.마틴
즉, 자신보다 변하기 쉬운 것에 의존하지 마라.
말 그대로 자신보다 변하기 쉬운 것에 의존하지 마라는 말이다. 구체적으로 추상클래스 또는 상위클래스는 구체적인 구현 클래스 또는 하위클래스에게 의존적이면 안된다. 왜냐면 구체적인 클래스는 코딩에 있어서 가장 전면적으로 노출되고 사용되기 때문에 변화에 민감하다.

# 참조사이트
* [객체 지향 설계란? (SOLID)](https://limkydev.tistory.com/77)
* [開発者が知っておくべきSOLIDの原則](https://postd.cc/solid-principles-every-developer-should-know/)