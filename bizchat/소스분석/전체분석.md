# 20201027
# 프로젝트 분석
1. SMS전체 과정

## 기술관련
1. RabbitMQTemplate 를 이용해서 Message송수신을 한다.
2. Listener는 SpringMessageQueueConfig에서 정의한다.

## 메시지 발송(MT/SMS)
0. RabbitMQListener/Template 생성
SpringMessageQueueConfig 에서 생성한다.

1. SMS 발송 요청(MQ발송 요청/DB요청 데이터 저장)
⓪ 메시지 타입
CommonCode::MessageSubType(SMS, LMS, MMS)
- SMS: /v1/sendSms
- LMS: /v1/sendLms
- MMS: /v1/sendMms

① (MT플로우 그림에서 6번까지이다)
MtController::sendSms->MtSendReqService::createMtSmsSndReq->MtMapper::insertMtSndReq->INSERT(MT_SND_REQ)
                                                          ->MtMapper::insertMtMsgQueue->INSERT(MT_MSG_QUEUE)
                     ->ApiSender::sendMtMgrRequest-> MessageStatus.WAIT -> MQ:PUSH
② (MT매니저-요청 플로우 그림 7번까지)
MtMgrRequestQueueListener::onMessage -> MessageStatus.REQ
                    -> MtMgrService::modifyMtMsgQueue(메시지 상태변경) -> UPDATE(MT_MSG_QUEUE)
                    -> RlcAgentService::saveInfoBackMtMessage (인포뱅크용 Agent 경유 => 사용안함)
                    -> MtMgrService::sendMsgReq (메시지별 직접 통신사 송신)
                        -> SMS:MtSmsSender::sendMtSmsSktRequest -> MQ:PUSH
                        -> LMS:MtMmsSender::sendMtMmsSktRequest -> MQ:PUSH
                        -> MMS:MtMmsSender::sendMtMmsSktRequest -> MQ:PUSH

②-1 (통신사 SMS클라이언트 수신)
...ing...
=> 시작
Bootstrap   -> Component스캔: Bootstrap::start -> SpringRootConfig 에서 수행(com.skt.mate.config)
            -> ApplicationEventListener::ApplicationListener<ContextClosedEvent> => ApplicationContext가 클로즈될때 호출된다.

SpringSmsSktConfig => @Configuration 에서 수행한다.(큐리스너, Netty핸들러, 프로시저등등)

=> MQ리스너 설정후 queue에 put
QueueListener: SmsSktQueueListener::onMessage -> 메시지 Retry 카운트 체크
                                            -> SmsSendManager::sendMessage -> SmsSktClient::sendMessage -> queue::put         

=> 루프에서 queue에서 poll
SmsSktClient::run -> ::queue::poll -> ::toSmsPayload 단말기에 보낼 전문을 생성한다.
                  -> channel::writeAndFlush 단말기로 송신[Netty:송신]
                  -> MessageStatus.RETRY 실패시
                    -> MQ:PUSH


=> 단말기 전송후 단말기로부터 수신 메시지 처리[Netty:수신]
SmsSktHandler::channelRead0 -> ResultRequestProcedure::process -> MessageStatus.CMPL/MessageStatus.RETRY/MessageStatus.FAIL
                            -> MessageStatus.CMPL -> SmsSktQueueSender::sendMtMgrResult -> MQ:PUSH(MT_MGR_RESULT) -> (MT매니저-수신플로우)

? RCS단말 결과값 코드가 어떻게 되는지 물어야함.

③ (MT매니저-수신 플로우 그림 8번)
MtMgrResultQueueListener::onMessage 
                    -> 단말기에서 메시지 수신(MSG.CMPL)
                    -> MtMgrService::searchOpenApiSendResultNotification (DB 전송결과조회)
                    -> MtMgrService::sendCallback(최종 결과 OpenAPI호출 그림 10번) -> ApiCallBackSender::sendApiCallBackRequest() -> MQ::API_CALLBACK

(그림 11번 ~ 13번)
ApiCallbackQueueListener::onMessageCommon -> (CRM에 Noti를 Http로 전송) -> AsynCustomerCallbackSender::run -> (CRM전송 결과 DB저장)

2. SKT SMS클라이언트
SmsSktClient::connection

## 메시지 발송(MT/MMS)
0. 쿼리/설정파일
mt.sqlmap.xml
api.properties.xml

1. MMS발송 요청
/v1/SendMms

2-1. 캐시접속 인증 및 API 권한 조회
OpenApiCommonFilter::doFilter -> CustomerCacheService::findCustomerInfo (캐시에서 User정보조회하고, 헤더에 키값: loginUser로  customerIpList와 리소스 리스트를 담는다)

2-2. 캐시실패 인증 및 API 권한 조회
OpenApiCommonFilter::doFilter -> CustomerCacheService::findCustomerInfo -> 예외발생
                              -> MtSendReqService::searchUserInfo
3. 사용 가능한 특번 조회
MtController::sendMms -> MtSendReqService::searchCheckValidationInfo(VO::SpcNum(스팩번호)) -> 실퍠경우(예외발생)

4. 첨부파일 검증
5. 첨부파일 저장(to 스토리지)
MtController::sendMms -> 테이블 COM_CD_GRP(ID:MMS_FILE_MIME_TP) 조회로 MIME타입 취득 -> 저장 -> ApiFileCommonUtil::multipartFileSave -> 존재여부/파일확장자 검증#


6. MMS발송 요청 정보 저장(to DB)
MtController::sendMms -> MessageStatus.WAIT -> MtSendReqService::createMtMmsMsgQueue 
                                                    -> DB: MT 발송 내역 등록 -> INSERT(MT_SND_REQ)
                                                    -> DB: MT 발송요청 상세정보 내역 등록 -> INSERT(MT_MSG_QUEUE)
                                                    -> DB: MT 발송요청 MMS 내 첨부파일 등록 -> INSERT(MT_MSG_QUEUE_BIN)

* MT_MSG_QUEUE: 전송중인 테이블

7. MMS발송 요청(MQ Push)
MtController::sendMms 
          -> MessageSubType.MMS 
          -> MessageStatus.WAIT 
          -> ApiSender::sendMtMgrRequest(MtMessage) -> QueueName.MT_MGR.MT_MGR_REQUEST -> MQ:PUSH

8. MMS발송 요청 응답
MtController::sendMms -> resHeader(성공여부) GSON.toJson(resVO)

9. MMS 전송 결과 MQ Push
MtMgrRequestQueueListener::onMessage -> MtMgrService::searchMtMsgQueueInfo
                                        -> DB: 조회 -> SELECT(MT_MSG_QUEUE[userid, mtqueueid])
                                     -> DeviceCacheService::findDeviceInfo
                                        -> CACHE: 조회 -> JPA(device)
                                     -> MtMgrService::modifyMtMsgQueue -> MessageStatus.REQ or FAIL
                                        -> DB: 갱신 -> UPDATE(MT_MSG_QUEUE)
                                     -> 성공여부 
                                        -> 실패 -> MtMgrService::sendMtMgrReultByFinalFail
                                                    -> MtMgrResultSenderByFinalFail::sendMtMgrResult -> QueueName.MT_MGR.MT_MGR_RESULT -> MQ:PUSH
                                        -> 성공
                                            -> SKT아닌경우(AGENT를 통해 발송)
                                                -> RlcAgentService::saveInfoBackMtMessage
                                            -> SKT경우
                                                -> MtMgrService::sendMsgReq (메시지별 직접 통신사 송신)
                                                -> SMS:MtSmsSender::sendMtSmsSktRequest -> MQ:PUSH
                                                -> LMS:MtMmsSender::sendMtMmsSktRequest -> MQ:PUSH
                                                -> MMS:MtMmsSender::sendMtMmsSktRequest -> QueueName.MT_MMS.MT_MMS_SKT -> MQ:PUSH

9-1. SKT MMS Client (메시지 복호화 처리 -> 파일정보 -> 발송 큐에 적재)
MmsSktQueueListener::onMessage -> QueueName.MT_MMS.MT_MMS_SKT -> ::findMtMsgQueue -> MmsMtMessageService::findMtMessageQueue -> 메시지 복호화 처리
                                                                                        -> DB : 조회 -> SELECT(MT_MSG_QUEUE[mtqueueid])
                               -> RclID 없다면
                                  -> CustomerService::findCustomerDetail -> DB: RclID 조회 -> 존재여부 -> 실패 -> 예외
                               -> RclID 있다면 (단말기 발송처리!!!!)
                                  -> MmsSendManager::sendMessage -> MmsMtMessageService::searchMtMessageQueueFileList
                                                                      -> MmsMtMessageService::selectMtMsgQueueBinList
                                                                        -> DB: 단말기 MMS 첨부파일 조회 -> SELECT(MT_MSG_QUEUE_BIN)
                                                                      -> MmsSktClient::sendMessage -> queue:put
9-2. SKT MMS Client (발송 큐에서 메시지 취득후 발송후 단말로 부터 Submit RES 메시지 받는다. (발송에 대한 결과값이 반환이 아니다.))
MmsSktClient::run -> 연결이 끊어져있다면
                    -> Queue의 모든 메시지 -> MessageStatus.RETRY -> MmsSktQueueSender::sendMtMgrRequest
                  -> 연결되어 있다면
                    -> ::queue::poll -> CommonCode.MessageStatus.REQ -> MmsMtMessageService::modifyMtMessageQueue
                                                                          -> DB: 메시지 상태 변경 -> UPDATE(MT_MSG_QUEUE)
                                     -> ::sendMessage (실제 전송처리!!!)
                                          -> SktDeliverySubmit::toByte (메시지 전체 바이트 변환 - SOAP형태) -> 파일 전문 처리 -> 전체적으로 SOAP처리 -> 전체 byte변환
                                          -> OutputStream::write 

                                          ...ing...
                                          -> 최종 file에 대한 [덤프처리여부 => 덤프파일위치]덤프처리
                                          -> disconnect -> 연결끊음

10-1. VMG서버로 MMS전송 오류 결과는 MQ PUSH(대상: Retry/커넥션실패/실패) (문서: 7.4.1, 7.4.2) 응답성공은 발송이 성공한것이지 발송결과를 받은건 아니다.
MmsSktClient::run -> ::sendMessage -> 응답 -> SktMmsUtils::parserSubmitResult
                                       -> XML응답 파싱: MessageID, StatusCode, StatusText
                  -> ::callBackResult 
                     -> 응답성공 (응답의 상태코드로 판단)
                        -> MmsMtMessageService::saveMtMessageQueue 
                           -> CommonCode.MessageStatus.REQ -> updateMtMsgQueue (발송중으로 갱신)
                                                               -> DB: 메시지 상태 변경 -> UPDATE(MT_MSG_QUEUE)
                           -> CommonCode.ProcessResult.SUCC -> insertMtMsgQueueActionHist (MT Action 이력 성공 처리)
                                                               -> DB: INSERT -> INSERT(MT_MSG_QUEUE_ACTION_HIST)
                     -> 응답실패 / Retry(응답의 상태코드로 판단)
                        -> MmsMtMessageService::saveMtMessageQueue
                           -> CommonCode.MessageStatus.RETRY -> updateMtMsgQueue (발송중으로 갱신)
                                                                  -> DB: 메시지 상태 변경 -> UPDATE(MT_MSG_QUEUE)
                           -> CommonCode.ProcessResult.FAIL -> insertMtMsgQueueActionHist (MT Action 이력 실패 처리)
                                                                  -> DB: INSERT -> INSERT(MT_MSG_QUEUE_ACTION_HIST)
                        -> MmsSktQueueSender::sendRetryMtMmsSkt 
                           -> MessageStatus.RETRY -> QueueName.MT_MMS.MT_MMS_SKT -> MQ:PUSH
                     -> 응답실패 / 컨넥션 실패
                        -> MmsMtMessageService::saveMtMessageQueue
                           -> CommonCode.MessageStatus.WAIT -> updateMtMsgQueue (갱신)
                                                                  -> DB: 메시지 상태 변경 -> UPDATE(MT_MSG_QUEUE)
                           -> MmsSktQueueSender::sendMtMgrRequest
                              -> MessageStatus.RETRY -> QueueName.MT_MGR.MT_MGR_REQUEST -> MQ:PUSH
                     -> 그외 전부 실패
                        -> MmsMtMessageService::saveMtMessageQueue
                           -> CommonCode.MessageStatus.FAIL -> updateMtMsgQueue (실패 갱신)
                                                                  -> DB: 메시지 상태 변경 -> UPDATE(MT_MSG_QUEUE)
                        -> MmsSktQueueSender::sendMtMgrResult
                           -> MessageStatus.FAIL -> QueueName.MT_MGR.MT_MGR_RESULT -> MQ:PUSH

10-2. MMS 전송 결과 수신 (VMG서버로부터 HTTP로 전송 결과를 보내온다.)
uri: /mms/mt/skt/delivery_report
SktDeliveryReportController::deliveryReportReq 
               -> MmsSktReportService::saveDeliveryReport
                     -> CommonCode.MtActionType.REQUEST 
                     -> RESULT (성공)
                        -> MmsMtMessageService::saveMtMessageQueue
                           -> MessageStatus.CMPL -> updateMtMsgQueue (완료)
                                 -> DB: 메시지 상태 변경 -> UPDATE(MT_MSG_QUEUE)
                           -> CommonCode.ProcessResult.SUCC -> insertMtMsgQueueActionHist (MT Action 이력 성공 처리)
                                 -> DB: INSERT -> INSERT(MT_MSG_QUEUE_ACTION_HIST)
                     -> RESULT (통신사변경)
                        -> MmsMtMessageService::saveMtMessageQueue
                           -> MessageStatus.RETRY -> updateMtMsgQueue (리트라이)
                                 -> DB: 메시지 상태 변경 -> UPDATE(MT_MSG_QUEUE)
                           -> CommonCode.ProcessResult.FAIL -> insertMtMsgQueueActionHist
                                 -> DB: INSERT -> INSERT(MT_MSG_QUEUE_ACTION_HIST)
                     -> RESULT (리트라이)
                        -> MmsMtMessageService::saveMtMessageQueue
                           -> MessageStatus.RETRY -> updateMtMsgQueue (리트라이)
                                 -> DB: 메시지 상태 변경 -> UPDATE(MT_MSG_QUEUE)
                           -> CommonCode.ProcessResult.FAIL -> insertMtMsgQueueActionHist
                                 -> DB: INSERT -> INSERT(MT_MSG_QUEUE_ACTION_HIST)
                     -> RESULT (실패)
                        -> MmsMtMessageService::saveMtMessageQueue
                           -> MessageStatus.FAIL -> updateMtMsgQueue (실패)
                                 -> DB: 메시지 상태 변경 -> UPDATE(MT_MSG_QUEUE)
                           -> CommonCode.ProcessResult.FAIL -> insertMtMsgQueueActionHist
                                 -> DB: INSERT -> INSERT(MT_MSG_QUEUE_ACTION_HIST)
                  -> RESULT(성공)
                     -> MessageStatus.CMPL -> QueueName.MT_MGR.MT_MGR_RESULT -> MQ:PUSH 
                  -> RESULT(통신사변경)
                     -> MessageStatus.RETRY -> QueueName.MT_MGR.MT_MGR_REQUEST -> MQ:PUSH 
                  -> RESULT(리트라이)
                     -> MessageStatus.RETRY -> QueueName.MT_MMS.MT_MMS_SKT -> MQ:PUSH 
                  -> RESULT(실패)
                     -> MessageStatus.FAIL -> QueueName.MT_MGR.MT_MGR_RESULT -> MQ:PUSH
               -> 성공
                  -> MmsStatusCode.SUCCESS
               -> 실패
                  -> MmsStatusCode.SERVER_ERROR
               -> ::buildResponse (★:8 VMG버서에 응답 메시지는 SOAP 형식으로 전달한다.!!!!)

11. MMS 전송 결과 (QueueName.MT_MGR.MT_MGR_RESULT)
MtMgrResultQueueListener::onMessage -> MtMgrService::searchOpenApiSendResultNotification (조회)
                                          -> DB: MT_QUEUE_ID 조회 -> SELECT(MT_SND_HIST, CUSTOM, CRM_SERVER, SYSTEM_USER, MT_MSG_QUEUE)
                                    -> MtMgrService::modifyMtMgrResult(★:7)
                                          -> ... ing(상담/설문 비즈챗에 따라 분기 처리가 있다.)
                                    -> 성공 (MessageStatus.CMPL)
                                       -> CACHE: 발송 결과 성공인 경우 디비아스 정보를 저장
                                    -> MtMgrService::sendCallback(OpenAPI호출)
                                          -> ApiCallBackSender::sendApiCallBackRequest() -> QueueName.API.API_CALLBACK -> MQ:PUSH

12. MMS 전송결과 Notification 요청 (QueueName.API.API_CALLBACK)
ApiCallbackQueueListener::onMessageCommon -> MtSendReqService::searchOpenApiSendResultNotification
                                                -> DB: MT_QUEUE_ID 전송 결과 조회 -> SELECT(MT_SND_HIST, CUSTOM, CRM_SERVER, SYSTEM_USER, MT_MSG_QUEUE)
                                          -> ExecutorService::execute 
                                             -> AsynCustomerCallbackSender::run()
                                                -> CloseableHttpClient::execute(CRM에 Noti를 Http로 전송)
                                                -> 응답(13번으로...)
13. MMS 전송결과 Notification 응답
14. MMS 전송결과 Notification 응답코드 저장(DB)
AsynCustomerCallbackSender::run() -> 히스토리 여부 (응답코드 DB 저장)
                                       -> Y
                                          -> MtSendReqService::saveCustomNotificationResultToHistory
                                             -> MtSndHistMapper::updateMtSndHist
                                                -> DB: 히스토리 갱신 -> UPDATE(MT_SND_HIST)
                                             -> MtSndHistMapper::insertMtSndActionHist
                                                -> 성공/실패 (ProcessResult.SUCC/ProcessResult.FAIL)
                                                -> DB: 히스토리 저장 -> INSERT(MT_SND_ACTION_HIST)

                                       -> N
                                          -> MtSendReqService::saveCustomNotificationResult
                                             -> MtMapper::updateMtMsgQueue
                                                -> DB: 큐정보 -> UPDATE(MT_MSG_QUEUE)
                                             -> MtMapper::insertMtMsgQueueActionHist
                                                -> 성공/실패 (ProcessResult.SUCC/ProcessResult.FAIL)
                                                -> DB: 히스토리 저장 -> INSERT(MT_MSG_QUEUE_ACTION_HIST)

                                 -> 실패
                                       -> RetrySender::sendApiCallbackRetry -> QueueName.API.API_CALLBACK_RETRY


# 비즈챗 Web 분석
자료: 비즈챗_RCS_Web_Wireframe_v0.3
기동방법: wiki->04.개발->개발서버프로세스체크
## 비지니스 비즈챗 web(v1.2.7,1.2.8)
1. 설문등록
고객사(web) -> 서비스관리 -> 설문조사 -> 설문제작 -> 등록
2. 설문조회-확인(web)
고객사(web) -> 서비스관리 -> 설문조사 -> 설문관리 -> 검색
3. 설문승인
어드민(admin) -> 서비스관리 -> 설문승인 -> 조회

## 이전설문불러오기
화면: 이전설문불러오기->리스트선택->불러오기
SurveyController::beforeSurveyPupUp
   -> ProjectMgmtService::searchProjectList -> ProjectMapper::selectProjectList
      -> DB: 프로젝트 리스트

   -> 리스트선택 
      -> SurveyController::beforeSurvey -> ProjectMapper::getBeforeSurvey

## 설문등록(화면: 설문제작)
/survey/surveyRegist -> surveyRegist.jsp
SurveyController::registSurvey => surveyRegist.jsp 
   -> 화면표시
      -> SurveyController::registSurvey      
         -> ChargeAndSpcNumService::searchCustomChargeBuyList -> DB: 요금제 구매 리스트 조회 -> SELECT(CHARGE_SVC)
         -> SurveyMgmtService::isUseTargetYn -> DB: 중계사 조회 -> SELECT(RLC)
         -> ChargeAndSpcNumService::getCustomSpcNumTotalCnt -> DB: 특번 카운트 조회 -> SELECT(custom_spc_num/custom_spc_num_svc/custom)
         -> ChargeAndSpcNumService::searchCustomSpcNumList -> DB: 특번 리스트 조회 -> SELECT(custom_spc_num/custom_spc_num_svc/custom)
         -> ProjectMgmtService::searchProjectList -> DB: 프로젝트 리스트 조회 -> SELECT(SURVEY_PROJECT/SURVEY/SYSTEM_USER)
         -> RETURN(VO: SurveyProjectVO)
   -> 등록
      -> SurveyController::saveSurvey(VO:ServeyVO)
         -> ChargeAndSpcNumService::searchCustomChargeBuyList -> DB: 요금제 구매 리스트 조회 -> SELECT(CHARGE_SVC)            
         -> ProjectMgmtService::selectProject(VO:SurveyProjectVO) -> DB: 프로젝트 조회 -> SELECT(SURVEY_PROJECT/SURVEY/SYSTEM_USER)
         -> ★ 첨부 이미지처리(복수 이미지) -> 이미지 검증(Tika라이브러리/확장자 검증등) 
            -> ★ SurveyMgmtService::saveSurvey(SurveyVO/CustomerContactVO) -> DB: 설문 등록 ->    <== 이것을 RCS용도로 별도로 작성을 하는 방법 생각
               -> SurveyMapper::deleteSurveyTarget -> DB: 기존 데이터 삭제 -> DELETE(SURVEY_TRGTER)
               -> SurveyMapper::deleteSurveyRjtTarget -> DB: 기존 데이터 삭제 -> DELETE(SURVEY_RCV_RJTER)           
               -> ★ ::surveyFileUpload -> FileUtil.transferTo -> FILE: 이미지 업로드
               -> 상태
                  -> SurveyCode.SurveyStateCd.TEMP_SAVE (임시저장)
                  -> SurveyCode.SurveyStateCd.REGISTER (등록요청)
                     -> ★ SurveyMapper::insertSurvey -> DB: 설문 저장 -> INSERT(SURVEY)
                     -> ::saveMail -> 관리자 문자 알림
               -> 루프처리
                  -> ★ ::qustImgUpload(설문이미지들) -> FileUtil.transferTo -> FILE: 업로드
                  -> ★ SurveyMapper::insertSurveyQuestion() -> DB:설문질문 이미지/쿠폰 등록 -> INSERT(SURVEY_QUST)
            -> 성공/실패
               -> resultMap(surveySeq/resultMessage/resCd)               

설문조회
selectSurvey

화면: 설문관리
surveyList.jsp
SurveyController::getSurveyList

## 설문승인(화면: 관리자->설문승인)
### 화면동작
uri:survey/reqlist -> 화면: 설문승인 -> surveyReqList.jsp -> 설문상태: REGISTER
   -> [승인]
      -> 타게팅이 있을때 처리
      -> 타게팅 없을때 처리
         -> /survey/updateState -> 설문상태: APPR

   -> [반려]

### 소스동작 (ADMIN)
화면: 설문 리스트 -> 설문승인 동작
SurveyController::getSurveyReqlist
   -> SurveyMgmtService::searchSurveyRequestList -> DB: 설문승인 예정 조회 -> SELECT(SURVEY/SYSTEM_USER/CUSTOM/SURVEY_PROJECT)

SurveyController::updateState
   -> SurveyMgmtService::updateTargetingSurvey 
      -> 받는 폰넘버 파일 잇으면 
         -> SurveyCode.SurveyStateCd.APPR -> 설문상태: APPR
            -> DB: deleteSurveyTarget, moveSurveyTarget, updateSurveyForTarget, insertSurveyStateHistory
      -> 받는 폰넘버 파일 없으면
         -> DB: updateSurveyState, insertSurveyStateHistory
      -> SurveyMgmtService::saveMail

# 스케쥴러 분석(mmate-survey-agent)
## 초기실행
BootStrap::start ->
   SenderApplicationConfig
      -> BEAN: MessageSource
      -> BEAN: ThreadPoolTaskScheduler
      -> ★ BEAN: SchedulerSendMsgSearchTask
      -> BEAN: SchedulerMoveTask

### 10분 (설문상태: APPR -> RUNNING 처리)

SchedulerStartSurveyTask::startSurvey
   -> SurveyMapper::selectSurveyForScheduler -> 설문상태: APPR -> DB: 설문상태(APPR) 조회 -> SELECT(SURVEY)
      -> 루프처리(APPR리스트)
         -> ::startSurvey(SurveySeq별로 루프)
            -> 설문 정보
               -> SurveyMapper::selectSurvey -> DB: 설문조회 -> SELECT(SURVEY)
            -> 동시간대 진행중인 설문중 중복 MDN 처리
               -> SurveyMapper::updateSurveyDupTrgter -> 설문상태: RUNNING -> DB: 설문상태 갱신 -> UPDATE(SURVEY_TRGTER/) 
            -> 발송대상자
               -> SurveyMapper::selectSurveyTrgter -> DB: 대상자 조회 -> SELECT(SURVEY_TRGTER)
            -> 고객특번확인
               -> getCustomSpcNumList
            -> 비즈챗 사용확인
               -> getCustomSvcList
            -> ★ 루프처리
               -> ★ 이미지PATH 없음(SurveyVO::SurveyAgreImgFilePath => 코폰이미지)
                  -> SMS/LMS 처리
               -> ★ 이미지PATH 있음
                  -> MMS 처리
            -> ★ SenderService::createSndMsgBatch 
               -> SenderMapper::insertSndMsgBatch -> DB: 메시지 저장 -> INSERT(SND_MSG(SURVEY_SEQ포함)=> MSG_TP (SMS/LMS/MMS)) => ★RCS용도로 SND_MSG에 관련내용을 포함할 것인가...고민
            -> ★ SenderService::createSndAttrFileBatch (첨부이미지 저장처리)
               -> SenderMapper::insertSndAttrFileBatch -> DB: 이미지정보 저장 -> INSERT(SND_ATTFILE)
         -> 상태: RUNNING
         -> 상태: ERROR
         -> updateSurveyStateCd -> DB: 설문상태 RUNNING/ERROR 갱신 -> UPDATE(SURVEY)
   
### 3분
★ SchedulerSendMsgSearchTask
   -> ::sendLms
   -> ::sendSms
   -> ★ ::sendMms
      -> SurveyService::getSurveyByStateAndDate
         -> DB: 설문 RUNNING 상태 조회 -> SELECT(SURVEY)
      -> SenderService::searchListSendMsgForMms
         -> DB: 메시지 내용 조회 -> SELECT(SND_MSG) -> SND_MSG 에서 MMS이고, SURVEY_SEQ인 리스트 취득
      -> MtMessageService::saveSendMessage
         -> ★ 많은일을 한다.
         -> MtMsgQueueVO(CustomReqId=SndMsg:MSG_SEQ 포함)
         -> ::createMtMsgQueue(MtSndReqVO, MtMsgQueueVO, MtMsgQueueBinVO)
            -> DB: 정보입력 -> INSERT(MT_SND_REQ)
            -> DB: 정보입력 -> INSERT(★ MT_MSG_QUEUE)
            -> DB: 이미지 정보입력 -> INSERT(MT_MSG_QUEUE_BIN)
         -> ★ MessageQueueSender::sendMtMgrRequest(MtMessage) -> MessageStatus.WAIT -> QueueName.MT_MGR.MT_MGR_REQUEST -> MQ:PUSH

### 수신부분 ...ing
SurveyService::sendAnsErrNotiMsg
SurveyService::sendSurveyCoupon -> sendMsg
ReceiveMsgHandler::sendSurvey -> SurveyService::sendSurveyCoupon
ReceiveMsgHandler::sendSurvey -> SurveyService::sendSurveyQuestion
   -> createSndMsg ->insertSndMsg -> DB: 메시지 저장 -> INSERT(SND_MSG)

### MSG_REQUEST(mmate-mt-mgr) 
9. MMS 전송 결과 MQ Push
MtMgrRequestQueueListener::onMessage 
   -> MtMgrService::searchMtMsgQueueInfo
      -> DB: 조회 -> SELECT(MT_MSG_QUEUE[userid, mtqueueid])
   -> DeviceCacheService::findDeviceInfo
      -> CACHE: 조회 -> JPA(device)
   -> MtMgrService::modifyMtMsgQueue -> MessageStatus.REQ or FAIL -> QUEUE상태 갱신
      -> DB: 갱신 -> UPDATE(MT_MSG_QUEUE)
   -> 성공여부 
      -> 실패 -> MtMgrService::sendMtMgrReultByFinalFail
                  -> MtMgrResultSenderByFinalFail::sendMtMgrResult -> QueueName.MT_MGR.MT_MGR_RESULT -> MQ:PUSH
      -> 성공
         -> SKT아닌경우(AGENT를 통해 발송)
            -> RlcAgentService::saveInfoBackMtMessage
         -> SKT경우
            -> MtMgrService::sendMsgReq (메시지별 직접 통신사 송신)
               -> SMS:MtSmsSender::sendMtSmsSktRequest -> MQ:PUSH
               -> LMS:MtMmsSender::sendMtMmsSktRequest -> MQ:PUSH
               -> MMS:MtMmsSender::sendMtMmsSktRequest -> QueueName.MT_MMS.MT_MMS_SKT -> MQ:PUSH



### mms client
MmsSktClient::toSubmit -> SktDeliverySubmit -> 최종 딜리버리용 객체를 만든다.이것을 이용하여 RCS도 이용하도록 한다.

..ing

@@@#@#@#@#
MtMsgQueueVO 클래스와 MtMsgQueueVO용도의 DB스키마를 RCS용을 추가하면 어떨까 싶다.

* MMS같은 경우 MtMsgQueue를 MtMsgQueueInfo에 파일과 컨텐츠를 담아서 클라이언트에 전송을 한다.
MmsSendManager::sendMessage ->  MmsSktClient::sendMessage(MtMsgQueueInfo)
* RCS라면 위와 비슷하게 처리하도록 고민해보자..


9-1. SKT MMS Client (메시지 복호화 처리 -> 파일정보 -> 발송 큐에 적재)
MmsSktQueueListener::onMessage -> QueueName.MT_MMS.MT_MMS_SKT -> ::findMtMsgQueue -> MmsMtMessageService::findMtMessageQueue -> 메시지 복호화 처리
                                                                                        -> DB : 조회 -> SELECT(MT_MSG_QUEUE[mtqueueid])
                               -> RclID 없다면
                                  -> CustomerService::findCustomerDetail -> DB: RclID 조회 -> 존재여부 -> 실패 -> 예외
                               -> RclID 있다면 (단말기 발송처리!!!!)
                                  -> MmsSendManager::sendMessage -> MmsMtMessageService::searchMtMessageQueueFileList
                                                                      -> MmsMtMessageService::selectMtMsgQueueBinList
                                                                        -> DB: 단말기 MMS 첨부파일 조회 -> SELECT(MT_MSG_QUEUE_BIN)
                                                                      -> MmsSktClient::sendMessage -> queue:put
9-2. SKT MMS Client (발송 큐에서 메시지 취득후 발송후 단말로 부터 Submit RES 메시지 받는다. (발송에 대한 결과값이 반환이 아니다.))
MmsSktClient::run -> 연결이 끊어져있다면
                    -> Queue의 모든 메시지 -> MessageStatus.RETRY -> MmsSktQueueSender::sendMtMgrRequest
                  -> 연결되어 있다면
                    -> ::queue::poll -> CommonCode.MessageStatus.REQ -> MmsMtMessageService::modifyMtMessageQueue
                                                                          -> DB: 메시지 상태 변경 -> UPDATE(MT_MSG_QUEUE)
                                     -> ::sendMessage (실제 전송처리!!!)
                                          -> SktDeliverySubmit::toByte (메시지 전체 바이트 변환 - SOAP형태) -> 파일 전문 처리 -> 전체적으로 SOAP처리 -> 전체 byte변환
                                          -> OutputStream::write 

                                          ...ing...
                                          -> 최종 file에 대한 [덤프처리여부 => 덤프파일위치]덤프처리
                                          -> disconnect -> 연결끊음








# 설문 전체 라이프사이클 상태
등록 -> STAT:REGIST -> 승인 -> STAT:APPR -> 스케쥴:10분 -> STAT:RUNNING -> 스케쥴:3분 -> MSG_STAT:WAIT -> MQ:PUSH

* 관련테이블
SURVEY(과금유형:surveyMsgTp(기존: LMS, MMS/추가: RCS_LMS, RCS_MMS))
   - 파일경로
      RcverPhoneNumFileUrl
      RcvRjtPhoneNumFileUrl
      SurveyAgreImgFilePath
      SurveyComplImgFilePath
      AgreCouponCdFileUrl
      CouponCdFileUrl

SURVEY_TRGTER
SURVEY_RCV_RJTER
SURVEY_AGRE_COUPON
SURVEY_QUST (설문질문 이미지/쿠폰등등)
* 나스(파일)경로


## MMS발송 요청
AsyncTaskSender::senderForMms 
      -> agent.properties.xml(/v1/sendMms) 
      -> SenderService::selectListSendAttFile -> ★ DB: 첨부파일 조회 -> SELECT(SND_ATTFILE)
      -> ★ 전송데이터 작성후 HTTP요청 
         -> ★ CloseableHttpClient::execute

### 프렘웍분석
## 최초시작
WebApplicationInitializer 
    -> AbstractContextLoaderInitializer
        -> AbstractAnnotationConfigDispatcherServletInitializer
            -> WebApplicationConfig
               -> SpringRootConfig
               -> SpringWebDataSourceConfig
               -> SpringSecurityConfig
                  -> Bean: AuthenticationManager
                  -> Bean: AuthenticationProvider
                  -> Bean: FilterChainProxy
               -> SpringWebConfig
               

    -> AbstractSecurityWebApplicationInitializer
    -> JerseyWebApplicationInitializer
    -> SpringBootServletInitializer

SpringServletContainerInitializer::onStartup -> StandardContext.java::startInternal -> 

# mmate_web
# 분석
## 초기실행
WebApplicationConfig::
    -> XSSServletFilter::doFilterInternal
        -> CommonsMultipartResolver::isMultipart
            -> 이면
                -> CommonsMultipartResolver::resolveMultipart (* 파일업로드...관련)
            -> 아니면
                -> /survey/saveSurvey
                    -> 이면
                        -> XssRequestWrapperForSurvey::createRequest
                    -> 아니면
                        -> XssRequestWrapper::createRequest

0. 로컬 기동됨....
http://localhost:8080/mmate-web-local/main
1. 인증처리
SpringSecurityConfig::(순서: authenticate -> filter)
      => authenticationProvider
         -> UsernameAuthenticationProvider::authenticate 
            -> CustomerContactService::loadUserByUsername 
               => 성공 
                  -> SecurityContextHolder.getContext.setAuthentication
               => 실패
                  -> 각 로그인 실패별 예외처리 throw ①
                  -> CustomerContactService::modifyLoginFail (실패 카운트)
      => UsernamePasswordAuthenticationFilter
         => 성공
            -> LoginSuccessHandler
         => 실패
            -> onAuthenticationFailure
               -> ① 로그인 실패 예외를 받아서 session에 저장

2. 로그인 화면 표시
LoginController::login
..ing


1. 설문제작
설문등록: SurveyController::registSurvey => surveyRegist.jsp=> SurveyController::saveSurvey
2. 설문수정
3. 설문통계
4. 설문통계 (상세리포트)
5. 설문통계 (설문 이력 조회)
6. 설문내역통계



## 프론트 잠깐 조사
1. JSP
- thymeleaf사용
2. 분석
프론트와 비지니스간 통신을 알아보기 위해 FAQ 등록에 관련하여 조사중....
테이블: FAQ 
JAVA: FaqController::registSave
JSP: faqRegist.jsp(faqId는 어디서 세팅되는지 찾는중...)
흐름: faq/list->faq/regist (여기서는 faqId를 hidden처리되어 있음)
INSERT쿼리 돌때마다 주키 시퀀스는 아래 설정된 sequence 쿼리를 이용한다.
```SQL
create sequence FAQ_SEQ start with 1 increment BY 1 maxvalue 999999999999999999;
```

### 조사
Message의 RlcID 는 무엇?

### 파일전성
1. properties::api.mms.attach.file.max 를 이용해서 파일 개수 설정

# RCS 기획의도
## LMS/RCS 탭 작성 경우
작성(과금유형) > 발송
------------------------------------
일반(LMS)/RCS(LMS) > 일반(LMS)/RCS(RCS_LMS)
일반(MMS)/RCS(LMS) > 일반(MMS)/RCS(RCS_MMS)
일반(LMS)/RCS(MMS) > 일반(MMS)/RCS(RCS_MMS)
일반(MMS)/RCS(MMS) > 일반(MMS)/RCS(RCS_MMS)

## 단일 탭 작성 경우
작성(과금유형) > 발송
------------------------------------
일반(LMS)/RCS(작성안함) > 일반(LMS)
일반(MMS)/RCS(작성안함) > 일반(MMS)
일반(작성안함)/RCS(LMS) > RCS(RCS_LMS)
일반(작성안함)/RCS(MMS) > RCS(RCS_MMS)

## RCS_LMS/MMS 구분
구분 방법은 
1. 컨텐츠에 슬라이드 이미지 유무에 따라 LMS/MMS 가 된다.
2. 슬라이드 수에 따라 LMS/MMS가 된다. (슬라이드가 2~6개 있는 경우 과금유형이 MMS로 전환합니다.)

# 미팅 준비
## 도메인 지식
1. (★:7)비즈챗중에 상담 비즈챗, 설문 비즈챗 용도 및 차이?

## 문의사항
1. RCS도 통신사별 처리가 있는가?(내부 코드는 통신사별 QUEUE가 존재)
2. 코드그룹(COM_CD_GRP)테이블은 언제 Insert 되는가? 관련 sql이 있는가?
3. MMS전송시 첨부파일(JPG, JPEG)를 스토리지에 저장한다. RCS와 차이점은?
4. AGENT의 역할이 구체적으로 무엇인가? RCS도 AGENT를 사용하는 경우가 있는가?
5. DB에서 MessageQueue 정보 조회시 사용하는 RLC(중계사), DLC(딜러) 테이블은 무엇인가? 이와같은 테이블이 더 있는지? 있다면 각각의 명세는?
6. MMS 최종 Client에서 전송시 SOAP처리를 한다. RCS도 마찬가지로 SOAP포맷이 있는가?
7. RCS 최종 전송에 대한 응답 전문 포맷은 Soap(XML)형태인가? 
   - 응답상태 코드별 행동은?
   - 미지원 단말 여부
8. ★:8 MMS전송 결과를 VMG가 HTTP를 이용해서 전송하고 이에대한 결과 응답 전문이 있는듯 하다... RCS도 응답 전문이 있는가?(SktDeliveryReportController)

## TODO
- [X] 두 분께 개발기 DBMS 접근권한 부여 중입니다. 금일 중으로 작업완료 됩니다. 사용법은 첨부 참고하세요.
- [X] RCS 메시지 편집기로 제작한 RCS CONTENTS는 기존 MMS CONTENTS와 유사하게 DB 및 NAS에 나누어 저장해야 합니다.
- [] 개발 관련해서는 신규 Repository를 생성하지 마시고, 기존 mmate-web 및 mmate-admin에 feature branch를 생성하여 구현을 진행 해주시기 바랍니다.
    - rcs client 프로젝트가 필요해 보이고, 관련 신규 Repository가 필요해 보임..
    - RCS의존하는 모든 프로젝트들에 대한 수정이 필요해 보임.(MSG Status/Type등등, MSG분기처리)
- [] RCS CONTENTS를 어떤 방법으로 기존 DB TABLE과 신규 DB TABLE에 나누어 저장하실 것인지에 대한 계획을 미리 준비해서 설명해 주세요.
    - 현재까지 SMS/MMS같이 메시지 타입별로 테이블을 관리하고 있지 않고, 하나의 테이블에 타입으로 구분되어 사용되고 있음.. RCS를 추가하게 되면 테이블이 추가 되는것이 아닌
      컬럼이 메타정보에 따라 추가될 수 있을것으로 보임. (관련테이블: ) ※ ..ing 이부분 상세 조사 필요

- [] SiteMesh 사용법(jsp 태그에도 사용 sitemesh)
- [] 통계처리

- [] 연동 API 규격은 여기서 보실 수 있습니다.  https://app.swaggerhub.com/apis/MaaP_KR/RCS_Biz_Center/1.1.1
- [] 발송 API 규격은 이것 입니다. https://app.swaggerhub.com/apis/MaaP_KR/MaaP_FE_KR/1.1.6
- [] RCS스팩문서 속독
   - 5.1. 챗봇메시지가이드_BestCase_191115
   - 20200630_포멧_리스트_v11.3_메시지_밸리데이션_포함
   - RCC.07-v11.0

- [] RCS 시나리오/도메인 분석
- [] 통계 처리
- [] RCS 설계(워크 플로우/스펙) 착수
- [] RCS 프로젝트 생성

- [X] 이번 프로젝트 범위 (설문/통계/리포트)
- [X] 기존 운영업체가 언제까지인가? 11월 말? (형상관리 관련)


# 회의
1. WEB/ADMIN 로그인 권한들이 있다.
2. 상태: 승인요청/반려 => 수정이 된다.
3. 페이지
   240~2(리포트),
   '마이페이지': RCS client 를 등록해야 하는가?
4. 관리자아이디, 서브아이디가 있다. 고객사별 관리자 아이디는 1개이고, 서브아이디는 여러개이다. 
5. 통계
6. RCS작성 -> 관리자화면(231페이지-설문승인)->발송/반려/승인,  설문조회: 발송이 완료된것을 말함.   

# 고객사 미팅
## 비지니스 및 로직 설명
- 설문은 skt만한다.
- RCS는 cid필요없을듯.토큰을 이용한다.
- 모듈 agent/agent-test는 테스트용도
- async는 엑셀같은 다운로드 하기위한 모듈
- batch는 더이상 사용하지 않는 정보등을 지운다.
- cache(mdn, 고객정보), common, mq 는 공통 모듈
- mobile 관련 프로젝트는 관리자 화면에는 있으나 아직은 사용하지 않는다.(고객이 없다..)
- survey-agent 설문서버이다.(RCS 개발시 관련있다.)
- agent, survey-agent가 사용하는 테이블은 SND_MSG, RCV_MSG이다. survey-agent가 3초마다 SND_MSG를 조회해서 API를 호출해서 MT_SND_REQ에 전송플로우를 타도록 한다.
  - 관련테이블: SND_MSG, MT_SND_SEQ, MT_MSG_QUEUE, MT_SND_HIST, RCV_MSG
  - 주요소스: ReceiveMsgHandler.java 와 scheduler 패키지
  - SurveyService 는 메시지는 또 발송 할 것인지에 대한 로직이 있다.

## 고객사 요청사항
1. 변경될 코드 및 항목들이 어떤것이 있는지 (공통코드, 디비테이블, 나스디렉토리)어떻게 바뀔것인지 안이 나와야 한다.(일정을 알림은 금주중으로...)
2. 1번사항이 어느정도 구체화가 되면 고객사에서는 RCS 클라이언트 스켈레톤 개발이 가능하다.



# RCS개발
## RCS분석
1. 메시지 발송이 가능한 스켈레톤 코드 지원

## RCS적용
1. Admin-Dashboard에 RCS LMS/MMS 집계 추가
DashboardController.java/dashboard.jsp::dashboard 에서 dataMap에 성공 + 실패 + 누적 건수를 표현한다.

## 개발
1. Spring Boot 에서 RabbitMQ의 Template의 용도
- [Spring Boot AMQP](https://spring.io/projects/spring-amqp#overview)

2. Spring Event
- [イベントの伝播](https://www.techscore.com/tech/Java/Others/Spring/4-3/)

3. Spring Security
- [Hello World で学ぶ Spring Security の仕組み](https://qiita.com/opengl-8080/items/d4971ec4d2365c85ff99) <== 짱이네
- [Spring Security概要](https://terasolunaorg.github.io/guideline/5.1.0.RELEASE/ja/Security/SpringSecurity.html)
- [Spring Securityのお話](http://kozake.hatenablog.com/entry/2016/09/13/220328)
- [Spring Security認証周りについて](https://qiita.com/nannou/items/2363b37516f6228a4b9d) <== 비즈챗

4. Netty (SKT Client Channel) 
- [Nettyの紹介](https://www.codeflow.site/ja/article/netty)
- [Nettyを使ってサーバーを実装してみた](https://qiita.com/haoyu_ma/items/e1989ae752500521825b)
- [Nettyを使ってクライアントを実装してみた](https://qiita.com/haoyu_ma/items/3c501a1a263ee48d9581)

5. 파일업로드
- [ファイルアップロード](https://terasolunaorg.github.io/guideline/1.0.3.RELEASE/ja/ArchitectureInDetail/FileUpload.html)
- [Spring MVCによるファイルアップロード](https://www.codeflow.site/ja/article/spring-file-upload)
- [Spring MVC ファイルのアップロード](https://qiita.com/MizoguchiKenji/items/0aa1f2b385e73c36c24d)

6. Tika
- [Apache Tika](https://tika.apache.org/)

## Camel & Blocking & grpc
https://access.redhat.com/documentation/ja-jp/red_hat_fuse/7.5/html/fuse_on_openshift_guide/camel-spring-boot-starter
https://camel.apache.org/manual/latest/stream-caching.html
https://qiita.com/mkyz08/items/de1b2fd17eb372e1472d
https://jcug-oss.github.io/article/why-do-we-have-to-learn-camel-q
https://qiita.com/daikuro/items/5e22c78c0342fde04b87
https://codezine.jp/static/ad/index.html?ref=https%3A%2F%2Fcodezine.jp%2Farticle%2Fdetail%2F11673&1
https://jongz.hatenablog.com/entry/2018/12/11/031744
https://alwayspr.tistory.com/44

https://qiita.com/legokichi/items/1f3b1bd51e206ffdd2a6
https://www.kimullaa.com/entry/2016/12/09/000129#%E3%83%96%E3%83%AD%E3%83%83%E3%82%AD%E3%83%B3%E3%82%B0IO
https://b.hatena.ne.jp/kencharos/
https://qiita.com/klme_u6/items/ea155f82cbe44d6f5d88



